<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[hexo博客主动推送到百度站长平台]]></title>
      <url>%2Fposts%2Fhexo%2Fhexo%E5%8D%9A%E5%AE%A2%E4%B8%BB%E5%8A%A8%E6%8E%A8%E9%80%81%E5%88%B0%E7%99%BE%E5%BA%A6%E7%AB%99%E9%95%BF%E5%B9%B3%E5%8F%B0.html</url>
      <content type="text"><![CDATA[推送百度站长平台百度站长平台有几种方式提交自己的链接 主动推送(实时) 自动推送 sitemap 或者自己手工提交，这里主要说以上三种方式。 主动推送第一种方式使用了baidu_url_submitter这个工具：首先在hexo根目录安装插件npm install hexo-baidu-url-submit --save然后在根目录_config.yml中增加12345baidu_url_submit: count: 1 ## 提交的链接数 host: www.zhishuo.info ## 在百度站长平台中注册的域名 token: token ## 百度站长平台里的token，在链接提交-自动提交-主动推送中有 path: baidu_urls.txt ## 这个是会自动生成要推送的url地址 count是控制几条数据会生成在baidu_urls.txt中，这里推荐首次使用时填写你所有博客的数量，然后修改为1即可。这里还要注意一个问题，站点配置文件中url: http://www.zhishuo.info这里一定要带上www要不然推送不成功。最后把deploy调整一下，就可以正常使用了。12345deploy: - type: git repository: https://github.com/imkratos/imkratos.github.io.git branch: master - type: baidu_url_submitter # baidu push hexo g会生成baidu_urls.txt文件。 hexo d会在部署完git代码之后，把新增的url也会推送到百度。 自动推送由于我是使用的hexo next主题，next主题中自带了此功能，在next主题根目录下_config.yml中找到baidu_push: false改为true即可。 sitemap此种方式好像被github官方禁止了，博主添加了发现效果不是很明显，需要使用的同学们可自行查找。 baidu_url_submitter作者]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo博客next主题修改静态资源为CDN]]></title>
      <url>%2Fposts%2Fhexo%2Fhexo%E5%8D%9A%E5%AE%A2next%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E4%B8%BACDN.html</url>
      <content type="text"><![CDATA[问题博主最近看到博客打开速度非常慢，点开chrome的开发者工具查看是由于css,js,图片加载太慢，故css,js换成了国内的cdn，图片换成了七牛云。打开主题配置文件_config.yml以下为修改方式:123456789101112131415161718192021222324252627282930vendors: # Internal path prefix. Please do not edit it. _internal: vendors # Internal version: 2.1.3 jquery: //cdn.bootcss.com/jquery/2.1.3/jquery.min.js # Internal version: 2.1.5 # Fancybox: http://fancyapps.com/fancybox/ fancybox: //cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js fancybox_css: //cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css # Internal version: 1.0.6 fastclick: //cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js # Internal version: 1.9.7 lazyload: //cdn.bootcss.com/jquery_lazyload/1.9.7/jquery.lazyload.min.js # Internal version: 1.2.1 velocity: //cdn.bootcss.com/velocity/1.3.1/velocity.min.js # Internal version: 1.2.1 velocity_ui: //cdn.bootcss.com/velocity/1.3.1/velocity.ui.min.js # Internal version: 0.7.9 ua_parser: //cdn.bootcss.com/UAParser.js/0.7.12/ua-parser.min.js # Internal version: 4.4.0 # http://fontawesome.io/ fontawesome: //cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css 最终打开时间由原来的20-40s，缩短到现在的5s左右，可能不稳定，但足够了。 以下是几个国内比较好的cdn网站 http://www.bootcdn.cn/ https://www.staticfile.org/ http://cdn.code.baidu.com/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JDK源码之HashMap]]></title>
      <url>%2Fposts%2Fjava%2FJDK%E6%BA%90%E7%A0%81%E4%B9%8BHashMap.html</url>
      <content type="text"><![CDATA[什么是HashMapHashMap是一个可以提供O(1)时间复杂度的数据结构，由数组和链表数据结构组成。在对存入的key进行hash之后，然后用hash值在数组上确定一个位置，把value对象以Node节点形式放入到数组的链表当中。 jdk1.8之后对此做了优化，因为如果发生了数据倾斜，可能会使数组某个下标的Node链表非常长，因为链表查询起来比较慢，所以1.8之后修改了，当Node链表长度大于8时，会把该下标位置的链表数据结构修改为红黑树的结构来保证查询的速度。当数据长度小于8时，会再修改为链表。 使用场景个人理解使用场景应该是在不需要复杂的查询，只需要一个Key对应一个Value，写入少的场景。因为像HashMap，ArrayList这种数据结构都提供了自动扩容的功能，像HashMap的负载因子是0.75，也就是当数组中75%的位置都有值以后会进行扩容。每次扩容的时候都涉及到每个数据的rehash和数组的复制，所以当写入数据量非常大的时候，会不断的进行rehash和复制，有可能会造成CPU占用率非常高(这只是个人平时学习的理解，如果有不对之处请大家指正)。 所以个人感觉HashMap的使用场景也是读多写少的场景，可以提供很快速度的读，写入的速度也可以，但如果提前知道Map里要放入多少数据，最好在new对象的时候，就手动指定出长度，这样可以避免rehash，从来变相提高使用效率。 源码实现 jdk1.8版本以下的代码都是代码在上面，解释在下面。 1234/** * The default initial capacity - MUST be a power of two. */ static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 这个值是HashMap默认初始化的长度，也就是16长。 123456/** * The maximum capacity, used if a higher value is implicitly specified * by either of the constructors with arguments. * MUST be a power of two &lt;= 1&lt;&lt;30. */ static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; //1073741824 这里按注释看，应该是HashMap支持的最大长度，如果超过这个值，则使用这个值。 1234/** * The load factor used when none specified in constructor. */ static final float DEFAULT_LOAD_FACTOR = 0.75f; 负载因子，当数组中有值的位数超过此阀值时，进行扩容。 123456789/** * The bin count threshold for using a tree rather than list for a * bin. Bins are converted to trees when adding an element to a * bin with at least this many nodes. The value must be greater * than 2 and should be at least 8 to mesh with assumptions in * tree removal about conversion back to plain bins upon * shrinkage. */ static final int TREEIFY_THRESHOLD = 8; 当数组单个位置超过此值后，会把数据结构修改为红黑树。 123456/** * The bin count threshold for untreeifying a (split) bin during a * resize operation. Should be less than TREEIFY_THRESHOLD, and at * most 6 to mesh with shrinkage detection under removal. */ static final int UNTREEIFY_THRESHOLD = 6; 当小于这个值时，修改为链表。 1234567/** * The smallest table capacity for which bins may be treeified. * (Otherwise the table is resized if too many nodes in a bin.) * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts * between resizing and treeification thresholds. */ static final int MIN_TREEIFY_CAPACITY = 64; ??? 1transient Node&lt;K,V&gt;[] table; 存放元素的数组。 12345678910/** * The next size value at which to resize (capacity * load factor). * * @serial */ // (The javadoc description is true upon serialization. // Additionally, if the table array has not been allocated, this // field holds the initial array capacity, or zero signifying // DEFAULT_INITIAL_CAPACITY.) int threshold; 这个变量是用来存放阀值的，也就是数组长度*0.75的值。 12345678910111213141516171819202122232425262728293031323334353637383940/** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity * (16) and the default load factor (0.75). */ public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted &#125;/** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial * capacity and the default load factor (0.75). * * @param initialCapacity the initial capacity. * @throws IllegalArgumentException if the initial capacity is negative. */ public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; /** * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial * capacity and load factor. * * @param initialCapacity the initial capacity * @param loadFactor the load factor * @throws IllegalArgumentException if the initial capacity is negative * or the load factor is nonpositive */ public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); &#125; 初始化时，如果是空的构造方法，会只设置负载因子的值为默认的0.75. 如果指定的initialCapacity超过MAXIMUM_CAPACITY，则值就为MAXIMUM_CAPACITY tableSizeFor函数会求出一个值作为HashMap的容量 123456789101112/** * Returns a power of two size for the given target capacity. */ static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; &#125; 初始化完毕 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; 说下参数的意思，hash就是通过key计算出的hash值，Key Value不用多说就是我们要放入的Key和Value，onlyIfAbsent这里我理解应该是，如果Key存在是否要替换对应Key的Value，这里传入的是false，evict应该是，是否自动扩容，默认是true。 声明变量tab数组，就是需要存放节点的数组。p则是放在数组下标位置的节点。n,i数组长度和位置下标。 代码逻辑12if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; 如果数组没有初始化或者长度为0，则进行初始化。resize()方法中的初始化代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * Initializes or doubles table size. If null, allocates in * accord with initial capacity target held in field threshold. * Otherwise, because we are using power-of-two expansion, the * elements from each bin must either stay at same index, or move * with a power of two offset in the new table. * * @return the table */ final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; 123456789if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; 这里判断现有的数组长度是否为0，如果当前数组长度大于0，并且大于或等于MAXIMUM_CAPACITY，则threshold等于int的最大值，返回当前数组。 newCap的值等于当前数组的长度*2old&lt;&lt;1，如果这个新值小于MAXIMUM_CAPACITY并且当前数组的长度 &gt;= DEFAULT_INITIAL_CAPACITY也就是16，newThr = oldThr &lt;&lt; 1;这句话的意思是新的阀值=老阀值*2。其实以上的意思就是如果符合条件了，把新数组的长度和阀值都扩大2倍。 12else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; 这里的意思是，如果老数组长度不大于0，并且老阀值大于0，把老阀值的值赋给新的数组长度，这里我没理解为什么要这么做。 1234else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; 如果以上条件都不满足，就会进行默认的初始化。也就是数组长度等于16，阀值等于12。 12345if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; 至此如果新的阀值还是0的话，会再次进行初始化，公式还是一样的，先根据新的数组长度*负载因子计算出阀值，如果新的数据长度小于长度最大值，并且三目表达式用来判断是否过界，如果不过界，返回计算的值，如果过界，返回int最大值。123threshold = newThr;Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];table = newTab; 到这里，基本上阀值和新的数组长度都已经初始化完了，创建了新的数组，开始初始化对象了。如果是构造方法里调用这里，到这里就已经结束了，因为数组，阀值，都已经初始化完毕了。再下面的代码是扩容的时候会进行调用的。 123456789101112131415161718192021222324252627282930313233343536373839404142if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; 到第7行为止，是表示如果老数组的下标位置只有一个节点没有链表也没有红黑树，就会把该位置的数组赋值给新数组，在新数组的位置是hash值&amp;数组的长度(这里我以前一直认为是取余)。 如果是红黑树，则进行树拆分((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);12345678910111213141516171819202122232425262728293031323334353637383940414243444546final void split(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int index, int bit) &#123; TreeNode&lt;K,V&gt; b = this; // Relink into lo and hi lists, preserving order TreeNode&lt;K,V&gt; loHead = null, loTail = null; TreeNode&lt;K,V&gt; hiHead = null, hiTail = null; int lc = 0, hc = 0; for (TreeNode&lt;K,V&gt; e = b, next; e != null; e = next) &#123; next = (TreeNode&lt;K,V&gt;)e.next; e.next = null; if ((e.hash &amp; bit) == 0) &#123; if ((e.prev = loTail) == null) loHead = e; else loTail.next = e; loTail = e; ++lc; &#125; else &#123; if ((e.prev = hiTail) == null) hiHead = e; else hiTail.next = e; hiTail = e; ++hc; &#125; &#125; if (loHead != null) &#123; if (lc &lt;= UNTREEIFY_THRESHOLD) tab[index] = loHead.untreeify(map); else &#123; tab[index] = loHead; if (hiHead != null) // (else is already treeified) loHead.treeify(tab); &#125; &#125; if (hiHead != null) &#123; if (hc &lt;= UNTREEIFY_THRESHOLD) tab[index + bit] = hiHead.untreeify(map); else &#123; tab[index + bit] = hiHead; if (loHead != null) hiHead.treeify(tab); &#125; &#125; &#125; 这里我大概理解是这样的，先对所有的节点进行遍历，然后通过一定条件来判断是否小于等于UNTREEIFY_THRESHOLD这个阀值，如果小于就切换为普通的链表，如果大于就继续在树上添加节点，由于博主对树现在理解不是很好，这里暂且这样，以后我会指定研究一下树的节构。 123456789101112131415161718192021222324252627282930else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; 这里就是链表节构了，也是把链表循环先读取出来。但是这里为什么分成了2个链表？并且分别放在了不同的位置上。至此，resize()方法执行完毕，让我们再回来继续看put方法。 以上我们写了resize()中详细的方法 有初始化数组的长度和阀值 对数组进行扩容时对链表，单节点，以及树不同的处理 12if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); 这里是数组长度对hash值求与值，如果该位置为null证明该位置没有放入元素，则放入新的元素。 1234Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; 这里判断，如果hash值相等并且key值相等，或者key的equest相等，就直接替换该位置的值。 12else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); 如果该位置的结构是树的，则调用树的插入方法，关于树的方法博主在这里暂不讨论，因为博主也不是特别理解树结构，以后会补充。 123456789101112for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; 如果是链表的话，循环所有的链表，如果有相等的key，直接替换该key对应的值，如果循环到最后也没有相等的，在链表上插入一个新的node节点，同时判断是否满足到达TREEIFY_THRESHOLD的条件，如果到达，会把数据结构变更为红黑树。 1234567if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; 如果到这里e已经存在了，因为e等于新放入的node节点。就把该节点移到链表最后一个，并且直接返回value值。 12345++modCount; if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; 记录修改的次数modCount是用来控制非法修改hashmap里的值，来抛出ConcurrentModificationException。并且判断数组长度是否大于阀值，如果大于了就要调用resize()进行扩容，afterNodeInsertion没有理解作用是什么，至此put方法全部执行完毕。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JDK源码之CopyOnWriteArrayList]]></title>
      <url>%2Fposts%2Fjava%2FJDK%E6%BA%90%E7%A0%81%E4%B9%8BCopyOnWriteArrayList.html</url>
      <content type="text"><![CDATA[什么是CopyOnWriteArrayListCopyOnWriteArrayList是一个线程安全的List，和它相同的还有这几个,Vectory,SynchronizedList。它们都是实现了List接口的线程安全类。 CopyOnWriteArrayList使用的是一种写时复制的算法，也就是说在执行add方法的时候，并不像传统的ArrayList一样在当前数组直接操作，而是在执行add方法的时候，会把原来的数组复制并且长度+1，然后把新值设置到新的数组中，然后把新数组设置为当前使用状态，由于数组是volatile修饰的，所以JVM会自动来保证数组的可见性。 这样使此List在读取时可以不用加锁，提高读取效率，但是在添加的时候效率会很低下。所以我感觉CopyOnWriteArrayList的使用场景就是读多写少的场景，甚至在尽可能的情况下，不去写。这样才能发挥此数据结构的最大优点。 源码实现1234/** The lock protecting all mutators */final transient ReentrantLock lock = new ReentrantLock();/** The array, accessed only via getArray/setArray. */private transient volatile Object[] array; 数组结构和可重入锁，由于数组是volatile修饰的，所以JVM会利用CPU的缓存失效功能，将对象保持强一致性。假设有4个CPU，因为每个CPU都有属于自己的高速缓存，在此类对象进行更改时，JVM会调用CPU方法，将所有CPU的缓存失效，并且把修改后的内容刷回主存来保持此对象的强一致性，不知道这里我理解的有没有问题，如果有问题请各位指正。123456/** * Creates an empty list. */public CopyOnWriteArrayList() &#123; setArray(new Object[0]);&#125; 默认初始化，是一个0长度的数组。 1234567891011121314151617181920/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;) */ public boolean add(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125; &#125; 这里便是添加元素的代码，这里使用了重入锁，重入锁的意思是如果当前线程已经拿到了锁，再次获取此对象上的锁的时候，也会获得到锁不会排队。 上锁以后，先得到当前的数组，并取得当前的长度，然后调用Arrays.copyOf方法，复制数组并且长度+1，然后把新的元素加到新的数组中，设置新的数组为当前使用的数组。返回添加成功，并且释放锁。 1234567891011121314151617181920212223242526272829/** * Removes the element at the specified position in this list. * Shifts any subsequent elements to the left (subtracts one from their * indices). Returns the element that was removed from the list. * * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E remove(int index) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; E oldValue = get(elements, index); int numMoved = len - index - 1; if (numMoved == 0) setArray(Arrays.copyOf(elements, len - 1)); else &#123; Object[] newElements = new Object[len - 1]; System.arraycopy(elements, 0, newElements, 0, index); System.arraycopy(elements, index + 1, newElements, index, numMoved); setArray(newElements); &#125; return oldValue; &#125; finally &#123; lock.unlock(); &#125;&#125; 删除这里基本同增加一样，也是先加锁，然后再操作。 这里不同的是使用了int numMoved = len - index - 1;这个值来判断删除的元素是不是最后一个元素，如果是最后一个元素也就是numMoved=0，直接把原来的数组复制长度-1即可。 如果不是最后一个元素，则是分开复制的，先复制删除元素前面的数据，再复制删除元素后面的数据，最后形成新的数组，设置并返回，最后解锁。 123456789101112131415161718192021222324252627/** * Replaces the element at the specified position in this list with the * specified element. * * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E set(int index, E element) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); E oldValue = get(elements, index); if (oldValue != element) &#123; int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len); newElements[index] = element; setArray(newElements); &#125; else &#123; // Not quite a no-op; ensures volatile write semantics setArray(elements); &#125; return oldValue; &#125; finally &#123; lock.unlock(); &#125;&#125; 修改操作也类似，先加锁，得到原值，如果原值和修改的元素相等，其实感觉什么也没干，看这里注释只是为了保持volatile的语法。如果不等的话拷贝一个新的数组，在新的数组上修改值，把新的数组设置为当前使用的数组，返回修改之前的元素，解锁，完成。 12345678/** * &#123;@inheritDoc&#125; * * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E get(int index) &#123; return get(getArray(), index);&#125; 下标查找，这里看到和普通的数组没什么区别，就是普通的下标查找。 总结从源码来看，CopyOnWriteArrayList增，删，改，都会复制一下新的数组然后再设置回去，所以强烈建议此数据结构的使用场景基本是只读的，否则在大量操作的情况下性能应该会很慢(待以后数据验证)。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo next主题添加LeanCloud统计功能]]></title>
      <url>%2Fposts%2Fhexo%2Fhexo-next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0LeanCloud%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html</url>
      <content type="text"><![CDATA[遇到的问题网上能查到很多next主题添加LeanCloud主题的方法，但我看都是说在站点的_config.yml中添加1234leancloud_visitors: enable: true app_id: appid app_key: key 与是我也在站点的_config.yml中添加了，但不起作用。与是我又去主题的目录中添加了，报错。最后找到原因，是因为主题的_config.yml配置文件中已经自带了，在主题的_config.yml配置文件中308行左右，在这里直接配置即可。 参考资料next主题添加LeanCloud]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mac下使用springli创建springboot应用]]></title>
      <url>%2Fposts%2Fjava%2Fmac%E4%B8%8B%E4%BD%BF%E7%94%A8springli%E5%88%9B%E5%BB%BAspringboot%E5%BA%94%E7%94%A8.html</url>
      <content type="text"><![CDATA[环境准备生成springboot有以下几种方式 maven gradle springli spring官网可以点击生成脚手架 spring官网介绍说springli是最快的方式，所以我使用了springli来构建。 mac安装springli我使用的是brew安装，如果没使用过brew请移步brew. brew安装springli12$ brew tap pivotal/tap$ brew install springboot]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用hexo生成博客在github js css 404解决方案]]></title>
      <url>%2Fposts%2Fhexo%2F%E4%BD%BF%E7%94%A8hexo%E7%94%9F%E6%88%90%E5%8D%9A%E5%AE%A2%E5%9C%A8github-js-css-404%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html</url>
      <content type="text"><![CDATA[问题博主最近又开始写博客了，发现使用hexo next 主题，上传到github上之后，所有的vendors文件夹下的资源访问404，博主查了一些资料没有解决，故给github官方写了一封邮件，官方这样回复 Thanks for reaching out! We recently updated to Jekyll v3.3, which ignores the vendor folder by default. If you’re not using Jekyll, you can add a .nojekyll file to the root of your repository to disable Jekyll from building your site. Once you do that, your site should build with your vendor folder. 所以根据提示，在要目录下建立.nojekyll文件即可恢复正常，另外在hexo里，如果把文件放在source目录下，不会被生成到public目录中，根据github上网友的提示，把.nojekyll文件放在hexo主目录.deploy_git/ 文件夹下即可正常使用hexo d 上传，并且此文件也会上传到根目录。 2016-11-7号更新next主题源码更新了，把vendors目录改名了，更新为最新代码即可解决。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[读spring源码深度解析(二)]]></title>
      <url>%2Fposts%2Fjava%2F%E8%AF%BBspring%E6%BA%90%E7%A0%81%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90(%E4%BA%8C).html</url>
      <content type="text"><![CDATA[不明白DefaultListableBeanFactory.java中使用了AccessController.doPrivileged()方法，个人理解此方法好像是以当前上下文执行一些代码。javaUtilOptionalClass这个属性，是用了JDK8的java.util.Optional,此类是用来避免在Java中出现各种null的问题,但不知道为什么是写在了静态代码块中，而且是以动态加载的方式来加载的。 初始类从DefaultListableBeanFactory.java类的getBean()中，开始对整个工厂类进分析。 静态导入，如果你多次用到某个工具类的静态方法，可以使用静态导入，这样使代码更整洁美观。SimpleAliasRegistry.java这个类实现了对Alias的一些操作。BeanFactory.java接口定义一些对Bean的基本操作。DefaultSingletonBeanRegistry.java对spring对Bean的一些操作做了各种封装，创建，消毁，依赖等。AbstractAutowireCapableBeanFactory.java对AutowireCapableBeanFactory定义的方法进行了实现，此类XmlBeanDefinitionReader.java实现了用xml解析资源文件，并且实现了DefaultListableBeanFactory.java类 xml如果要使用DTD文件来验证的话，需要在xml文件头中加入&lt;!-- DOCTYPE 在解析DTD和XSD时，使用的是不同的机制，如果是DTD的话，会直接取到systemid在当前目录下寻找，如果是xsd时，会在META/schemas中找到对应的systemid 在解析xml时，如果设置了ResourceLoader，就使用用户设置的，如果没有设置，就使用默认的ResourceEntityResolver解析，解析Xml是使用的SAX方法解析，解析出来Document之后，会把Document进行解析，进行Bean的注册。 在注册的时候，使用了一个class类的cast方法，感觉这个方法使用的比较好，以前没有见过这种强制转换类型的使用，使用的DefaultBeanDefinitionDocumentReader.java来注册Bean，这里注册Bean的那些Map，是使用的SimpleBeanDefinitionRegistry.java类，如果没有指定应该是DefaultSingletonBeanRegistry.java?,注册的时候还会返回此次注册的类的数量。创建这个对象XmlReaderContext不知道是什么作用，里面是对XmlBeanDefinitionReader的一些封装，解析的时候还留了一前一后，供子类自己实现。DefaultBeanDefinitionDocumentReader.java中是对xml的解析，先根据标签来，然后再解析其中所有的属性，把xml组装成Java对象GenericBeanDefinition.java 解析Bean标签过程，获取id和name，如果没有指定id，就用name做这个类的key检查类名的唯一性判断此xml是否配置了一系列Spring的属性，并且在对应的Java对象中，设置对应的属性。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[阅读ActiveMQ源码总结]]></title>
      <url>%2Fposts%2Fjava%2F%E9%98%85%E8%AF%BBActiveMQ%E6%BA%90%E7%A0%81%E6%80%BB%E7%BB%93.html</url>
      <content type="text"><![CDATA[准备工作 下载源码git clone https://github.com/apache/activemq.git 使用maven编译源码并且下载依赖mvn clean install 导入到开发工具eclipsemvn eclipse:eclipse 或者idea mvn idea:idea 默认会去maven中央仓库下载jar包，如果下载速度慢可以翻墙或者改成开源中国的镜像仓库12345678&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;CN&lt;/id&gt; &lt;name&gt;OSChina Central&lt;/name&gt; &lt;url&gt;http://maven.oschina.net/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt;&lt;/mirrors&gt; 遇到的问题 idea导入之后无任何显示，事实证明楼主太着急，等编译之后就有了。。 客户端启动 java客户端代码我是按照《Java消息服务》这本书中的例子完成的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889 public class Chat implements javax.jms.MessageListener&#123; private TopicSession pubSession; private TopicPublisher publisher; private TopicConnection connection; private String username; /** * @param topicFactory * @param topicName * @param username * @throws Exception */ public Chat(String topicFactory,String topicName,String username) throws Exception &#123; //使用JNDI？ InitialContext ctx = new InitialContext(); //拿到工场 TopicConnectionFactory conFactory = (TopicConnectionFactory)ctx.lookup(topicFactory); //创建连接 TopicConnection connection = conFactory.createTopicConnection(); TopicSession pubSession = connection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE); TopicSession subSession = connection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE); Topic chatTopic = (Topic)ctx.lookup(topicName); TopicPublisher publisher = pubSession.createPublisher(chatTopic); String selector = "username=zhishuo"; TopicSubscriber subscriber = subSession.createSubscriber(chatTopic,selector,true); subscriber.setMessageListener(this); this.connection = connection; this.pubSession = pubSession; this.publisher = publisher; this.username = username; connection.start(); &#125; public void onMessage(Message message) &#123; try &#123; TextMessage textMessage = (TextMessage)message; System.out.println(textMessage.getText()); System.out.println(message.getJMSDestination()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 发送消息 * @param text * @throws JMSException */ protected void writeMessage(String text) throws JMSException &#123; TextMessage textMessage = pubSession.createTextMessage(username+":"+text); publisher.publish(textMessage); &#125; public void close() throws JMSException &#123; connection.close(); &#125; public static void main(String[] args) &#123; try &#123; if(args.length!=3)&#123; System.out.println("something is missing"); &#125; // topicFactory, topicName, username Chat chat = new Chat(args[0],args[1],args[2]); BufferedReader commondLine = new BufferedReader(new InputStreamReader(System.in)); while(true)&#123; String s = commondLine.readLine(); if(s.equalsIgnoreCase("exit"))&#123; chat.clone(); System.exit(0); &#125;else&#123; chat.writeMessage(s); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 还需要在classpath中加入jndi.properties 1234567891011#配置实现工场java.naming.factory.initial=org.apache.activemq.jndi.ActiveMQInitialContextFactory#配置activemq地址java.naming.provider.url=tcp://localhost:61616#这里是配置的安全机制？java.naming.security.principal=systemjava.naming.security.credentials=manager#订阅主题的名称，可以以逗号,隔开connectionFactoryNames=TopicCF#topictopic.topic1=jms.topic1 启动Chart类main方法时，传入TopicCF topic1 zhishuo这样客户端就可以正常启动，并且发送消息了，如果启动多个客户端，然后按回车发送消息，所有的人都可以看到。 代码分析 InitialContext ctx = new InitialContext();这里是JMS给出的公用调用方法，new对象时调用了默认的init()方法。myProps = (Hashtable&lt;Object,Object&gt;) ResourceManager.getInitialEnvironment(environment);里面主要是去加载当前环境变量和一些JVM设置的环境变量参数。 主要初始化都在getDefaultInitCtx()---&gt;NamingManager.getInitialContext(myProps);中完成，会在环境变量配置参数中找到String INITIAL_CONTEXT_FACTORY = &quot;java.naming.factory.initial&quot;;key值，由于我们这里配置的是java.naming.factory.initial=org.apache.activemq.jndi.ActiveMQInitialContextFactory，所以实例化的也就是ActiveMQInitialcontextFactory，最后再调用ActiveMQInitialcontextFactory.getInitialContext(env)这里传过去的参数是环境变量。 我们来到ActiveMQInitialcontextFactory.getInitialContext(env)方法中，此方法便是真正用来初始化队列，主题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public Context getInitialContext(Hashtable environment) throws NamingException &#123; // lets create a factory Map&lt;String, Object&gt; data = new ConcurrentHashMap&lt;String, Object&gt;(); String[] names = getConnectionFactoryNames(environment); for (int i = 0; i &lt; names.length; i++) &#123; ActiveMQConnectionFactory factory = null; String name = names[i]; try &#123; factory = createConnectionFactory(name, environment); &#125; catch (Exception e) &#123; throw new NamingException("Invalid broker URL"); &#125; /* * if( broker==null ) &#123; try &#123; broker = factory.getEmbeddedBroker(); &#125; * catch (JMSException e) &#123; log.warn("Failed to get embedded * broker", e); &#125; &#125; */ data.put(name, factory); // 实际上是 tocipIF ActiveMQConnectionFactory &#125; createQueues(data, environment); createTopics(data, environment); /* * if (broker != null) &#123; data.put("destinations", * broker.getDestinationContext(environment)); &#125; */ data.put("dynamicQueues", new LazyCreateContext() &#123; private static final long serialVersionUID = 6503881346214855588L; @Override protected Object createEntry(String name) &#123; return new ActiveMQQueue(name); &#125; &#125;); data.put("dynamicTopics", new LazyCreateContext() &#123; private static final long serialVersionUID = 2019166796234979615L; @Override protected Object createEntry(String name) &#123; return new ActiveMQTopic(name); &#125; &#125;); return createContext(environment, data); &#125; getConnectionFactoryNames方法中，是为了遍历并且初始化connectionFactoryNames配置的Value值，我们这里配置的connectionFactoryNames=TopicCF，这里用到了StringTokenizer感觉很好用，平时自己都是用string的split，没想到还有这种用法。然后遍历刚才解析的Value值，并且最终创建ActiveMQConnectionFactory对象返回。把创建好的对像放入Hashmap中，map.put(TopicCF,ActiveMQConnectionFactory)， failover://tcp://localhost:61616 这是此对象初始化时url属性的默认值初始化的时候修改成了tcp://localhost:61616 这里是每一个value值都对应一个自己的工厂类。 接下来创建Queues和Topics查找配置文件中以queue.和topic.开头的，并且生成ActiveMQQueue对象。我们这里配置的jms.topic1最后也放入map.put(topic1,ActiveMQTopic)。 接下来创建了动态的队列和主题，不知何用。dynamicQueuesdynamicTopics并且都放入了map最后创建了ReadOnlyContext对象，并且把相关的数据绑定都传入其中。至此第一句代码初始化完成。 (TopicConnectionFactory)ctx.lookup(topicFactory)这里是去加载实现工厂的类，由于上一个初始化最终返回的是ReadOnlyContext对象，所以这里调用的是ReadOnlyContext.lookup方法，我们来看public Object lookup(String name) throws NamingException {方法，这里其实就是根据传入的名称，取出相应的工厂，由于我们在启动时传入的工厂类名是TopicCF 所以，这里就是取出刚才放入的ActiveMQConnectionFactory工厂类，类图如下 conFactory.createTopicConnection()，这里是调用的ActiveMQConnectionFactory中的方法，该类中初始化了传输协议模式 123456789if (scheme.equals("auto")) &#123; connectBrokerUL = new URI(brokerURL.toString().replace("auto", "tcp")); &#125; else if (scheme.equals("auto+ssl")) &#123; connectBrokerUL = new URI(brokerURL.toString().replace("auto+ssl", "ssl"));&#125; else if (scheme.equals("auto+nio")) &#123; connectBrokerUL = new URI(brokerURL.toString().replace("auto+nio", "nio")); &#125; else if (scheme.equals("auto+nio+ssl")) &#123; connectBrokerUL = new URI(brokerURL.toString().replace("auto+nio+ssl", "nio+ssl")); &#125; 如果以上都没有配置，默认使用TCP协议传输，在TransportFactory.connect()--&gt;findTransportFactory()中，查找资源对应的配置协议，如果没有查到，使用默认的在private static final FactoryFinder TRANSPORT_FACTORY_FINDER = new FactoryFinder(&quot;META-INF/services/org/apache/activemq/transport/&quot;);此文件目录中，因为这里是用的tcp://localhost:61616所以这里使用的就是META-INF/services/org/apache/activemq/transport/tcp文件，此文件中实际配置的是TCP的传输器1class=org.apache.activemq.transport.tcp.TcpTransportFactory 然后调TcpTransportFactory.doConnect()进行连接，至此传输器创建完成。 接下来创建ActiveMQConnection连接 最后启动连接，并且设置一些默认值，至此创建连接完成，并返回连接。 TopicSession pubSession = connection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);创建发布和订阅Session，最终调用的是ActiveMQConnection.createTopicSession()，创建ActiveMQSession对像并返回。 Topic chatTopic = (Topic)ctx.lookup(topicName);加载主题，这里的值为topic1，因为在前边初始化的时候已经放入了对像，所以这里的值为ActiveMQTopic，调用ActiveMQSession.createPublisher() 和 createSubscriber() 创建发布者ActiveMQTopicPublisher和消费者ActiveMQTopicSubscriber。 创建完成之后，把自己设置为订阅者的监听器，最终启动连接，客户端启动代码分析完成，因为有一些自己也不是很理解，所以未能表达。 服务端启动 以下是服务端启动的类图调用关系: 这里还了解了java -D 是可以把一些参数设置到JVM中的 服务端启动这里充分体现了命令设计模式的案例，我认为是很好的学习例子，最终调用的是StartCommand.runTask()方法，类中有如下几个重要功能 初始化broker 添加JVM shutdownhook 停止时进行清理 下面来看broker = BrokerFactory.createBroker(configURI);此类中在创建工厂时也使用了文件配置的方法由于默认是使用的xbean:activemq.xml资源文件，所以在创建工厂时就是实例化的META-INF/services/org/apache/activemq/broker/xbean文件中配置的类，1class=org.apache.activemq.xbean.XBeanBrokerFactory 实际调用的是XBeanBrokerFactory.createBroker()此类中创建了Spring的ResourceXmlApplicationContext实现对象，但不知这里为何要这样。这里最后还调用了spring框架中refresh方法，此方法会初始化spring整个框架。最终创建一个BrokerService返回，broker中包含了所有上下文环境。 KahaDBPersistenceAdapter 调用关系图 KahaDBPersistenceAdapter 用例图 最后启动，至此服务启动完成。 问题]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[archLinux安装遇到的问题]]></title>
      <url>%2Fposts%2Flinux%2FarchLinux%E5%AE%89%E8%A3%85%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
      <content type="text"><![CDATA[pacman -Syy 更新之后才能用 启动ssh服务需要安装openssh,pacman -S openssh 启动sshd服务systemctl start sshd 设置为开机启动服务systemctl enable sshd.service 安装vim之后，显示libncursesw.so.6不能找到，运行pacman -Syu升级即可]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[读activeMQ源码(一)]]></title>
      <url>%2Fposts%2Fjava%2F%E8%AF%BBactiveMQ%E6%BA%90%E7%A0%81(%E4%B8%80).html</url>
      <content type="text"><![CDATA[最近的学习到了消息的阶段，查了下网上的资料，并没有很多具体介绍某一个消息中间件的源码是如何实现，帮自己下了源码想分析下去，希望能坚持。 源码GIT下载地址 下载完之后如果要导入eclipse 执行mvn eclipse:eclipse 或者导入IDEA mvn idea:idea 说下个人对rpc和消息的理解: 这2种方式从架构上就是不同的，rpc一般都是同步的，消息都是异步的，用在不同的场景上。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mac树莓派安装kaliLinux]]></title>
      <url>%2Fposts%2F%E6%A0%91%E8%8E%93%E6%B4%BE%2Flinux%2Fmac%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85kaliLinux.html</url>
      <content type="text"><![CDATA[树莓派到手大概有一周了，想折腾下kali linux，记录下安装步骤。 准备工作，必须品： 树莓派板子一个 5V电源一个 8G SD卡一张 kali linux img 下载地址 选择 “RaspberryPi 2” 版本即可 无线网卡或者网线 显示屏 windows安装怎样在Windows下将Kali安装到SD卡上 下载普通版的树莓派专用Kali Linux，并解压img。 下载名为Win32DiskImager的压缩包并解压其中exe后缀的软件。将SD卡插入你的PC中（记得用读卡器）。 双击打开Win32DiskImager.exe，如果你用的是WIN7或WIN8，则需要点击鼠标右键并选择“以管理员身份运行”。 如果该软件无法自动侦测到你的SD卡，你就要在右上角的下拉菜单中找到SD卡并手动选择它。 在软件的图像文件部分点击小文件夹的图标，找到你刚刚下载的Raspbian.img文件。 点击“写入 or write”按键，Win32DiskImager就会帮你完成其它步骤。安装过程结束后，你就可以拔出SD卡然后将其插入树莓派了。 mac or linux 安装怎样在OSX下将Kali安装到SD卡上 下载普通版的树莓派专用Kali Linux，并解压img。 SD卡插入电脑 使用df -h 命令查看你插入的SD卡，一般类似 /dev/disk0s4 每个人的机器数字是不一样的 使用diskutil list查看SD卡的名字，一般类似 /dev/disk4 然后使用diskutil unmount /dev/disk0s4 命令，卸载已经挂载的SD卡 使用diskutil list查看是否已经卸载，并使用sudo dd bs=4m if=kali-linux.img(这里是你解压img的名字) of=/dev/rdisk2(这里是你SD卡的位置) 写入完成就可以了，然后执行diskutil unmountDisk /dev/disk2推出SD卡。！！！这一步一定要执行，否则可能不会正常开机。你就可以拔出SD卡然后将其插入树莓派了。 树莓派开机 插入SD卡后可正常开机，kali linux 默认用户名密码 root toor 一定要自行修改，否则很可能会被人猜出来的。 说下坑 我查了网上各种资料，都没有给出IMG的下载地址，官网的armhf不能用好么，查了查文档也没找到在哪写的armhf和armel的区别。最终使用了上面我给出的下载地址，下完之后才可以用。 还有，下载之后要验证一下和官网的验证值是否一致，否则有可能自己就成了老黑客的肉鸡，验证方式下载网站已经给出。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[树莓派ntp时间同步问题]]></title>
      <url>%2Fposts%2F%E6%A0%91%E8%8E%93%E6%B4%BE%2F%E6%A0%91%E8%8E%93%E6%B4%BEntp%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98.html</url>
      <content type="text"><![CDATA[今天刚到手树莓派，看了下时间，于是上网搜了下时间同步的问题。然而我按照网上修改的同步服务器并不能解决问题，于是自己试着改了一下。 前提：你要选择正确了时区，运行sudo raspi-config 选择第4项，回车，继续选择第2个，回车，然后选择Aisa，回车，再次选择重庆或者上海，这样时区就调整好了。网上大部分都说在/etc/ntpd.conf 下 server 0.debain.pool.ntp.org iburst server 1.debain.pool.ntp.org iburst server 2.debain.pool.ntp.org iburst server 3.debain.pool.ntp.org iburst 调整服务器为server asia.pool.ntp.org iburst，我自己试了并不可以，于是我参考了一下我的Mac，用了苹果的时间同步服务器，最终修改为server time.apple.com iburst然后重启ntp服务sudo service ntp restart即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[读spring源码深度解析]]></title>
      <url>%2Fposts%2Fjava%2F%E8%AF%BBspring%E6%BA%90%E7%A0%81%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90.html</url>
      <content type="text"><![CDATA[工作也有几年了，以前也尝试过想要读spring源码，但由于前几年没有参考资料，所以很难去理解，最近发现一本spring源码深度解析，怀着试试看的心情，踏上了源码之路。 记录一下自己遇到的问题，初次读完之后感觉到了spring的强大之处，处处都是设计模式，把代码拆的很分散，但理解上就很难了。 源码下载，spring最新的git源码地址为spring源码 由于spring3.X以后就是使用gradle构建了，所以还需要安装gradle，Mac OS 可以使用HomeBrew brew install gradle 即可 安装好gradle以后，可以在想要查看的spring项目下执行gradle eclipse 生成eclipse的配置文件 最后在Eclipse-&gt;import-&gt;existing Eclipse projects进行导入就可以了 书中有一个查看类实现的接口图，一开始不知道在哪使用，后来发现对着想要查看的类右击，出现选项菜单，点击-&gt;Open Type Hierarchy 即可，默认是显示的子类实现，然后点击上方小图标show the supertype Hierarchy即可 书中作者看到了哪个类中没有做明确提示，如果找不到需要自行搜索，我用的STS，commond+shift+l 可按关键字搜索]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo博客提交到搜索引擎]]></title>
      <url>%2Fposts%2Fhexo%2Fhexo%E5%8D%9A%E5%AE%A2%E6%8F%90%E4%BA%A4%E5%88%B0%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E.html</url>
      <content type="text"><![CDATA[使用了hexo搭建博客之后，于是想把博客地址提交到搜索引擎当中，让搜索引擎来收录，在提交搜索引擎的时候遇到了一些问题记录下来。让搜索引擎收录的方式有以下几种: 提交某个html文件到你的博客根目录下 添加网站的meta标签 CNAME方式 当我使用第1种方式时，发现其实上传的文件是在index文件中包含了进来，所以搜索引擎不会识别，所以使用了第2种方式。在使用第2种方式时，是需要给index.html添加meta标签，使用hexo的话，如果直接修改.deploy是不可以的，因为执行hexo clean，hexo g两条命令后，是会把文件覆盖的。所以我直接修改了主题中的模板文件，这样在生成index.html的时候就会自动生成进来了。 修改themes-tyrant-layout-_partial-head.ejs文件把meta内容直接加入head即可。 ps:tyrant为博主使用的主题，修改时只需要修改自己主题下的此文件即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo 搭建 github pages 问题]]></title>
      <url>%2Fposts%2Fhexo%2Fhexo-%E6%90%AD%E5%BB%BA-github-pages--%E9%97%AE%E9%A2%98.html</url>
      <content type="text"><![CDATA[由于自己想搭建一个免费的博客，所以找到了万能的github，但在搭建的过程中遇到了几个小问题，所以记下来基本搭建的方法都是参考于利用github搭建博客这个博主已经写的很全了，搭建的过程就不一一提了说下遇到的问题 hexo上传后博客还是官方的建立了github pages的项目，并且使用了官方的建立建好了一个博客，官方默认会在master分支上开出一个gh-pages分支，然后查了官网资料说所有的内容都是显示gh-pages分支上的，但是我用hexo却传不到gh-pages分支上，并且传到了master分支内容也不会显示，后来找到原因是因为我建立的项目名字不是以#你的github帐户.github.io#命名的，所以会使hexo的上传程序传到master分支上也不会起作用，把项目名修改之后就可以了。 添加多说的问题在官网注册后，复制了多说代码，按教程做完之后发现多说模块不显示，所以查看了comment.ejs源代码&lt;% if (config.disqus_shortname &amp;&amp; page.comments){ %&gt; 这里是2个判断，把config.disqus_shortname &amp;&amp; 删掉之后，就可以正常使用了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我为什么开始写博客]]></title>
      <url>%2Fposts%2Funcategorized%2F%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%80%E5%A7%8B%E5%86%99%E5%8D%9A%E5%AE%A2.html</url>
      <content type="text"><![CDATA[最近参加了几场印象笔记的活动，听大家分享了一些自己坚持做的事，由于最近自己也在整理自己琐碎的事情，感觉虽然自己在技术上一直在积累但那都是自己的眼光和认识，如果与大家分享出来之后这样可以帮助自己有很大的提升。最近这一年来，在新的公司里自己有了很大的成长，但是发现这些成长记录其实只记录在我的印象笔记里或者是自己的经验上，并没有真正的分享出来，以后在这里记录自己遇到的问题以及一些正在学的技术，自己的理解和学习记录。希望在这里可以记录下自己技术成长的轨迹，以便和大家共同成长。]]></content>
    </entry>

    
  
  
</search>
