<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[hexo博客next主题修改静态资源为CDN]]></title>
      <url>%2F2016%2F11%2F15%2Fhexo%E5%8D%9A%E5%AE%A2next%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E4%B8%BACDN%2F</url>
      <content type="text"><![CDATA[问题博主最近看到博客打开速度非常慢，点开chrome的开发者工具查看是由于css,js,图片加载太慢，故css,js换成了国内的cdn，图片换成了七牛云。打开主题配置文件_config.yml以下为修改方式:123456789101112131415161718192021222324252627282930vendors: # Internal path prefix. Please do not edit it. _internal: vendors # Internal version: 2.1.3 jquery: //cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js # Internal version: 2.1.5 # Fancybox: http://fancyapps.com/fancybox/ fancybox: //cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js fancybox_css: //cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css # Internal version: 1.0.6 fastclick: //cdn.jsdelivr.net/fastclick/1.0.6/fastclick.min.js # Internal version: 1.9.7 lazyload: //cdn.jsdelivr.net/jquery.lazyload/1.9.3/jquery.lazyload.min.js # Internal version: 1.2.1 velocity: //cdn.jsdelivr.net/velocity/1.2.3/velocity.min.js # Internal version: 1.2.1 velocity_ui: //cdn.jsdelivr.net/velocity/1.2.3/velocity.ui.min.js # Internal version: 0.7.9 ua_parser: //cdn.jsdelivr.net/ua-parser.js/0.7.10/ua-parser.min.js # Internal version: 4.4.0 # http://fontawesome.io/ fontawesome: //cdn.bootcss.com/font-awesome/4.6.2/css/font-awesome.min.css 最终打开时间由原来的20-40s，缩短到现在的5s左右，可能不稳定，但足够了。 以下是几个国内比较好的cdn网站 http://www.bootcdn.cn/ https://www.staticfile.org/ http://cdn.code.baidu.com/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JDK源码之CopyOnWriteArrayList]]></title>
      <url>%2F2016%2F11%2F10%2FJDK%E6%BA%90%E7%A0%81%E4%B9%8BCopyOnWriteArrayList%2F</url>
      <content type="text"><![CDATA[什么是CopyOnWriteArrayListCopyOnWriteArrayList是一个线程安全的List，和它相同的还有这几个,Vectory,SynchronizedList。它们都是实现了List接口的线程安全类。 CopyOnWriteArrayList使用的是一种写时复制的算法，也就是说在执行add方法的时候，并不像传统的ArrayList一样在当前数组直接操作，而是在执行add方法的时候，会把原来的数组复制并且长度+1，然后把新值设置到新的数组中，然后把新数组设置为当前使用状态，由于数组是volatile修饰的，所以JVM会自动来保证数组的可见性。 这样使此List在读取时可以不用加锁，提高读取效率，但是在添加的时候效率会很低下。所以我感觉CopyOnWriteArrayList的使用场景就是读多写少的场景，甚至在尽可能的情况下，不去写。这样才能发挥此数据结构的最大优点。 源码实现1234/** The lock protecting all mutators */final transient ReentrantLock lock = new ReentrantLock();/** The array, accessed only via getArray/setArray. */private transient volatile Object[] array; 数组结构和可重入锁，由于数组是volatile修饰的，所以JVM会利用CPU的缓存失效功能，将对象保持强一致性。假设有4个CPU，因为每个CPU都有属于自己的高速缓存，在此类对象进行更改时，JVM会调用CPU方法，将所有CPU的缓存失效，并且把修改后的内容刷回主存来保持此对象的强一致性，不知道这里我理解的有没有问题，如果有问题请各位指正。123456/** * Creates an empty list. */public CopyOnWriteArrayList() &#123; setArray(new Object[0]);&#125; 默认初始化，是一个0长度的数组。 1234567891011121314151617181920/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &#123;@code true&#125; (as specified by &#123;@link Collection#add&#125;) */ public boolean add(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125; &#125; 这里便是添加元素的代码，这里使用了重入锁，重入锁的意思是如果当前线程已经拿到了锁，再次获取此对象上的锁的时候，也会获得到锁不会排队。 上锁以后，先得到当前的数组，并取得当前的长度，然后调用Arrays.copyOf方法，复制数组并且长度+1，然后把新的元素加到新的数组中，设置新的数组为当前使用的数组。返回添加成功，并且释放锁。 1234567891011121314151617181920212223242526272829/** * Removes the element at the specified position in this list. * Shifts any subsequent elements to the left (subtracts one from their * indices). Returns the element that was removed from the list. * * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E remove(int index) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; E oldValue = get(elements, index); int numMoved = len - index - 1; if (numMoved == 0) setArray(Arrays.copyOf(elements, len - 1)); else &#123; Object[] newElements = new Object[len - 1]; System.arraycopy(elements, 0, newElements, 0, index); System.arraycopy(elements, index + 1, newElements, index, numMoved); setArray(newElements); &#125; return oldValue; &#125; finally &#123; lock.unlock(); &#125;&#125; 删除这里基本同增加一样，也是先加锁，然后再操作。 这里不同的是使用了int numMoved = len - index - 1;这个值来判断删除的元素是不是最后一个元素，如果是最后一个元素也就是numMoved=0，直接把原来的数组复制长度-1即可。 如果不是最后一个元素，则是分开复制的，先复制删除元素前面的数据，再复制删除元素后面的数据，最后形成新的数组，设置并返回，最后解锁。 123456789101112131415161718192021222324252627/** * Replaces the element at the specified position in this list with the * specified element. * * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E set(int index, E element) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); E oldValue = get(elements, index); if (oldValue != element) &#123; int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len); newElements[index] = element; setArray(newElements); &#125; else &#123; // Not quite a no-op; ensures volatile write semantics setArray(elements); &#125; return oldValue; &#125; finally &#123; lock.unlock(); &#125;&#125; 修改操作也类似，先加锁，得到原值，如果原值和修改的元素相等，其实感觉什么也没干，看这里注释只是为了保持volatile的语法。如果不等的话拷贝一个新的数组，在新的数组上修改值，把新的数组设置为当前使用的数组，返回修改之前的元素，解锁，完成。 12345678/** * &#123;@inheritDoc&#125; * * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */public E get(int index) &#123; return get(getArray(), index);&#125; 下标查找，这里看到和普通的数组没什么区别，就是普通的下标查找。 总结从源码来看，CopyOnWriteArrayList增，删，改，都会复制一下新的数组然后再设置回去，所以强烈建议此数据结构的使用场景基本是只读的，否则在大量操作的情况下性能应该会很慢(待以后数据验证)。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo next主题添加LeanCloud统计功能]]></title>
      <url>%2F2016%2F11%2F10%2Fhexo-next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0LeanCloud%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD%2F</url>
      <content type="text"><![CDATA[遇到的问题网上能查到很多next主题添加LeanCloud主题的方法，但我看都是说在站点的_config.yml中添加1234leancloud_visitors: enable: true app_id: appid app_key: key 与是我也在站点的_config.yml中添加了，但不起作用。与是我又去主题的目录中添加了，报错。最后找到原因，是因为主题的_config.yml配置文件中已经自带了，在主题的_config.yml配置文件中308行左右，在这里直接配置即可。 参考资料next主题添加LeanCloud]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mac下使用springli创建springboot应用]]></title>
      <url>%2F2016%2F11%2F04%2Fmac%E4%B8%8B%E4%BD%BF%E7%94%A8springli%E5%88%9B%E5%BB%BAspringboot%E5%BA%94%E7%94%A8%2F</url>
      <content type="text"><![CDATA[环境准备生成springboot有以下几种方式 maven gradle springli spring官网可以点击生成脚手架 spring官网介绍说springli是最快的方式，所以我使用了springli来构建。 mac安装springli我使用的是brew安装，如果没使用过brew请移步brew. brew安装springli12$ brew tap pivotal/tap$ brew install springboot]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用hexo生成博客在github js css 404解决方案]]></title>
      <url>%2F2016%2F11%2F04%2F%E4%BD%BF%E7%94%A8hexo%E7%94%9F%E6%88%90%E5%8D%9A%E5%AE%A2%E5%9C%A8github-js-css-404%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
      <content type="text"><![CDATA[问题博主最近又开始写博客了，发现使用hexo next 主题，上传到github上之后，所有的vendors文件夹下的资源访问404，博主查了一些资料没有解决，故给github官方写了一封邮件，官方这样回复 Thanks for reaching out! We recently updated to Jekyll v3.3, which ignores the vendor folder by default. If you’re not using Jekyll, you can add a .nojekyll file to the root of your repository to disable Jekyll from building your site. Once you do that, your site should build with your vendor folder. 所以根据提示，在要目录下建立.nojekyll文件即可恢复正常，另外在hexo里，如果把文件放在source目录下，不会被生成到public目录中，根据github上网友的提示，把.nojekyll文件放在hexo主目录.deploy_git/ 文件夹下即可正常使用hexo d 上传，并且此文件也会上传到根目录。 2016-11-7号更新next主题源码更新了，把vendors目录改名了，更新为最新代码即可解决。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[读spring源码深度解析(二)]]></title>
      <url>%2F2016%2F03%2F09%2F%E8%AF%BBspring%E6%BA%90%E7%A0%81%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90(%E4%BA%8C)%2F</url>
      <content type="text"><![CDATA[不明白DefaultListableBeanFactory.java中使用了AccessController.doPrivileged()方法，个人理解此方法好像是以当前上下文执行一些代码。javaUtilOptionalClass这个属性，是用了JDK8的java.util.Optional,此类是用来避免在Java中出现各种null的问题,但不知道为什么是写在了静态代码块中，而且是以动态加载的方式来加载的。 初始类从DefaultListableBeanFactory.java类的getBean()中，开始对整个工厂类进分析。 静态导入，如果你多次用到某个工具类的静态方法，可以使用静态导入，这样使代码更整洁美观。SimpleAliasRegistry.java这个类实现了对Alias的一些操作。BeanFactory.java接口定义一些对Bean的基本操作。DefaultSingletonBeanRegistry.java对spring对Bean的一些操作做了各种封装，创建，消毁，依赖等。AbstractAutowireCapableBeanFactory.java对AutowireCapableBeanFactory定义的方法进行了实现，此类XmlBeanDefinitionReader.java实现了用xml解析资源文件，并且实现了DefaultListableBeanFactory.java类 xml如果要使用DTD文件来验证的话，需要在xml文件头中加入&lt;!-- DOCTYPE 在解析DTD和XSD时，使用的是不同的机制，如果是DTD的话，会直接取到systemid在当前目录下寻找，如果是xsd时，会在META/schemas中找到对应的systemid 在解析xml时，如果设置了ResourceLoader，就使用用户设置的，如果没有设置，就使用默认的ResourceEntityResolver解析，解析Xml是使用的SAX方法解析，解析出来Document之后，会把Document进行解析，进行Bean的注册。 在注册的时候，使用了一个class类的cast方法，感觉这个方法使用的比较好，以前没有见过这种强制转换类型的使用，使用的DefaultBeanDefinitionDocumentReader.java来注册Bean，这里注册Bean的那些Map，是使用的SimpleBeanDefinitionRegistry.java类，如果没有指定应该是DefaultSingletonBeanRegistry.java?,注册的时候还会返回此次注册的类的数量。创建这个对象XmlReaderContext不知道是什么作用，里面是对XmlBeanDefinitionReader的一些封装，解析的时候还留了一前一后，供子类自己实现。DefaultBeanDefinitionDocumentReader.java中是对xml的解析，先根据标签来，然后再解析其中所有的属性，把xml组装成Java对象GenericBeanDefinition.java 解析Bean标签过程，获取id和name，如果没有指定id，就用name做这个类的key检查类名的唯一性判断此xml是否配置了一系列Spring的属性，并且在对应的Java对象中，设置对应的属性。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[阅读ActiveMQ源码总结]]></title>
      <url>%2F2016%2F01%2F07%2F%E9%98%85%E8%AF%BBActiveMQ%E6%BA%90%E7%A0%81%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[准备工作 下载源码git clone https://github.com/apache/activemq.git 使用maven编译源码并且下载依赖mvn clean install 导入到开发工具eclipsemvn eclipse:eclipse 或者idea mvn idea:idea 默认会去maven中央仓库下载jar包，如果下载速度慢可以翻墙或者改成开源中国的镜像仓库12345678&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;CN&lt;/id&gt; &lt;name&gt;OSChina Central&lt;/name&gt; &lt;url&gt;http://maven.oschina.net/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt;&lt;/mirrors&gt; 遇到的问题 idea导入之后无任何显示，事实证明楼主太着急，等编译之后就有了。。 客户端启动 java客户端代码我是按照《Java消息服务》这本书中的例子完成的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889 public class Chat implements javax.jms.MessageListener&#123; private TopicSession pubSession; private TopicPublisher publisher; private TopicConnection connection; private String username; /** * @param topicFactory * @param topicName * @param username * @throws Exception */ public Chat(String topicFactory,String topicName,String username) throws Exception &#123; //使用JNDI？ InitialContext ctx = new InitialContext(); //拿到工场 TopicConnectionFactory conFactory = (TopicConnectionFactory)ctx.lookup(topicFactory); //创建连接 TopicConnection connection = conFactory.createTopicConnection(); TopicSession pubSession = connection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE); TopicSession subSession = connection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE); Topic chatTopic = (Topic)ctx.lookup(topicName); TopicPublisher publisher = pubSession.createPublisher(chatTopic); String selector = "username=zhishuo"; TopicSubscriber subscriber = subSession.createSubscriber(chatTopic,selector,true); subscriber.setMessageListener(this); this.connection = connection; this.pubSession = pubSession; this.publisher = publisher; this.username = username; connection.start(); &#125; public void onMessage(Message message) &#123; try &#123; TextMessage textMessage = (TextMessage)message; System.out.println(textMessage.getText()); System.out.println(message.getJMSDestination()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 发送消息 * @param text * @throws JMSException */ protected void writeMessage(String text) throws JMSException &#123; TextMessage textMessage = pubSession.createTextMessage(username+":"+text); publisher.publish(textMessage); &#125; public void close() throws JMSException &#123; connection.close(); &#125; public static void main(String[] args) &#123; try &#123; if(args.length!=3)&#123; System.out.println("something is missing"); &#125; // topicFactory, topicName, username Chat chat = new Chat(args[0],args[1],args[2]); BufferedReader commondLine = new BufferedReader(new InputStreamReader(System.in)); while(true)&#123; String s = commondLine.readLine(); if(s.equalsIgnoreCase("exit"))&#123; chat.clone(); System.exit(0); &#125;else&#123; chat.writeMessage(s); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 还需要在classpath中加入jndi.properties 1234567891011#配置实现工场java.naming.factory.initial=org.apache.activemq.jndi.ActiveMQInitialContextFactory#配置activemq地址java.naming.provider.url=tcp://localhost:61616#这里是配置的安全机制？java.naming.security.principal=systemjava.naming.security.credentials=manager#订阅主题的名称，可以以逗号,隔开connectionFactoryNames=TopicCF#topictopic.topic1=jms.topic1 启动Chart类main方法时，传入TopicCF topic1 zhishuo这样客户端就可以正常启动，并且发送消息了，如果启动多个客户端，然后按回车发送消息，所有的人都可以看到。 代码分析 InitialContext ctx = new InitialContext();这里是JMS给出的公用调用方法，new对象时调用了默认的init()方法。myProps = (Hashtable&lt;Object,Object&gt;) ResourceManager.getInitialEnvironment(environment);里面主要是去加载当前环境变量和一些JVM设置的环境变量参数。 主要初始化都在getDefaultInitCtx()---&gt;NamingManager.getInitialContext(myProps);中完成，会在环境变量配置参数中找到String INITIAL_CONTEXT_FACTORY = &quot;java.naming.factory.initial&quot;;key值，由于我们这里配置的是java.naming.factory.initial=org.apache.activemq.jndi.ActiveMQInitialContextFactory，所以实例化的也就是ActiveMQInitialcontextFactory，最后再调用ActiveMQInitialcontextFactory.getInitialContext(env)这里传过去的参数是环境变量。 我们来到ActiveMQInitialcontextFactory.getInitialContext(env)方法中，此方法便是真正用来初始化队列，主题1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public Context getInitialContext(Hashtable environment) throws NamingException &#123; // lets create a factory Map&lt;String, Object&gt; data = new ConcurrentHashMap&lt;String, Object&gt;(); String[] names = getConnectionFactoryNames(environment); for (int i = 0; i &lt; names.length; i++) &#123; ActiveMQConnectionFactory factory = null; String name = names[i]; try &#123; factory = createConnectionFactory(name, environment); &#125; catch (Exception e) &#123; throw new NamingException("Invalid broker URL"); &#125; /* * if( broker==null ) &#123; try &#123; broker = factory.getEmbeddedBroker(); &#125; * catch (JMSException e) &#123; log.warn("Failed to get embedded * broker", e); &#125; &#125; */ data.put(name, factory); // 实际上是 tocipIF ActiveMQConnectionFactory &#125; createQueues(data, environment); createTopics(data, environment); /* * if (broker != null) &#123; data.put("destinations", * broker.getDestinationContext(environment)); &#125; */ data.put("dynamicQueues", new LazyCreateContext() &#123; private static final long serialVersionUID = 6503881346214855588L; @Override protected Object createEntry(String name) &#123; return new ActiveMQQueue(name); &#125; &#125;); data.put("dynamicTopics", new LazyCreateContext() &#123; private static final long serialVersionUID = 2019166796234979615L; @Override protected Object createEntry(String name) &#123; return new ActiveMQTopic(name); &#125; &#125;); return createContext(environment, data); &#125; getConnectionFactoryNames方法中，是为了遍历并且初始化connectionFactoryNames配置的Value值，我们这里配置的connectionFactoryNames=TopicCF，这里用到了StringTokenizer感觉很好用，平时自己都是用string的split，没想到还有这种用法。然后遍历刚才解析的Value值，并且最终创建ActiveMQConnectionFactory对象返回。把创建好的对像放入Hashmap中，map.put(TopicCF,ActiveMQConnectionFactory)， failover://tcp://localhost:61616 这是此对象初始化时url属性的默认值初始化的时候修改成了tcp://localhost:61616 这里是每一个value值都对应一个自己的工厂类。 接下来创建Queues和Topics查找配置文件中以queue.和topic.开头的，并且生成ActiveMQQueue对象。我们这里配置的jms.topic1最后也放入map.put(topic1,ActiveMQTopic)。 接下来创建了动态的队列和主题，不知何用。dynamicQueuesdynamicTopics并且都放入了map最后创建了ReadOnlyContext对象，并且把相关的数据绑定都传入其中。至此第一句代码初始化完成。 (TopicConnectionFactory)ctx.lookup(topicFactory)这里是去加载实现工厂的类，由于上一个初始化最终返回的是ReadOnlyContext对象，所以这里调用的是ReadOnlyContext.lookup方法，我们来看public Object lookup(String name) throws NamingException {方法，这里其实就是根据传入的名称，取出相应的工厂，由于我们在启动时传入的工厂类名是TopicCF 所以，这里就是取出刚才放入的ActiveMQConnectionFactory工厂类，类图如下 conFactory.createTopicConnection()，这里是调用的ActiveMQConnectionFactory中的方法，该类中初始化了传输协议模式 123456789if (scheme.equals("auto")) &#123; connectBrokerUL = new URI(brokerURL.toString().replace("auto", "tcp")); &#125; else if (scheme.equals("auto+ssl")) &#123; connectBrokerUL = new URI(brokerURL.toString().replace("auto+ssl", "ssl"));&#125; else if (scheme.equals("auto+nio")) &#123; connectBrokerUL = new URI(brokerURL.toString().replace("auto+nio", "nio")); &#125; else if (scheme.equals("auto+nio+ssl")) &#123; connectBrokerUL = new URI(brokerURL.toString().replace("auto+nio+ssl", "nio+ssl")); &#125; 如果以上都没有配置，默认使用TCP协议传输，在TransportFactory.connect()--&gt;findTransportFactory()中，查找资源对应的配置协议，如果没有查到，使用默认的在private static final FactoryFinder TRANSPORT_FACTORY_FINDER = new FactoryFinder(&quot;META-INF/services/org/apache/activemq/transport/&quot;);此文件目录中，因为这里是用的tcp://localhost:61616所以这里使用的就是META-INF/services/org/apache/activemq/transport/tcp文件，此文件中实际配置的是TCP的传输器1class=org.apache.activemq.transport.tcp.TcpTransportFactory 然后调TcpTransportFactory.doConnect()进行连接，至此传输器创建完成。 接下来创建ActiveMQConnection连接 最后启动连接，并且设置一些默认值，至此创建连接完成，并返回连接。 TopicSession pubSession = connection.createTopicSession(false, Session.AUTO_ACKNOWLEDGE);创建发布和订阅Session，最终调用的是ActiveMQConnection.createTopicSession()，创建ActiveMQSession对像并返回。 Topic chatTopic = (Topic)ctx.lookup(topicName);加载主题，这里的值为topic1，因为在前边初始化的时候已经放入了对像，所以这里的值为ActiveMQTopic，调用ActiveMQSession.createPublisher() 和 createSubscriber() 创建发布者ActiveMQTopicPublisher和消费者ActiveMQTopicSubscriber。 创建完成之后，把自己设置为订阅者的监听器，最终启动连接，客户端启动代码分析完成，因为有一些自己也不是很理解，所以未能表达。 服务端启动 以下是服务端启动的类图调用关系: 这里还了解了java -D 是可以把一些参数设置到JVM中的 服务端启动这里充分体现了命令设计模式的案例，我认为是很好的学习例子，最终调用的是StartCommand.runTask()方法，类中有如下几个重要功能 初始化broker 添加JVM shutdownhook 停止时进行清理 下面来看broker = BrokerFactory.createBroker(configURI);此类中在创建工厂时也使用了文件配置的方法由于默认是使用的xbean:activemq.xml资源文件，所以在创建工厂时就是实例化的META-INF/services/org/apache/activemq/broker/xbean文件中配置的类，1class=org.apache.activemq.xbean.XBeanBrokerFactory 实际调用的是XBeanBrokerFactory.createBroker()此类中创建了Spring的ResourceXmlApplicationContext实现对象，但不知这里为何要这样。这里最后还调用了spring框架中refresh方法，此方法会初始化spring整个框架。最终创建一个BrokerService返回，broker中包含了所有上下文环境。 KahaDBPersistenceAdapter 调用关系图 KahaDBPersistenceAdapter 用例图 最后启动，至此服务启动完成。 问题]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[archLinux安装遇到的问题]]></title>
      <url>%2F2015%2F12%2F24%2FarchLinux%E5%AE%89%E8%A3%85%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[pacman -Syy 更新之后才能用 启动ssh服务需要安装openssh,pacman -S openssh 启动sshd服务systemctl start sshd 设置为开机启动服务systemctl enable sshd.service 安装vim之后，显示libncursesw.so.6不能找到，运行pacman -Syu升级即可]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[读activeMQ源码(一)]]></title>
      <url>%2F2015%2F12%2F09%2F%E8%AF%BBactiveMQ%E6%BA%90%E7%A0%81(%E4%B8%80)%2F</url>
      <content type="text"><![CDATA[最近的学习到了消息的阶段，查了下网上的资料，并没有很多具体介绍某一个消息中间件的源码是如何实现，帮自己下了源码想分析下去，希望能坚持。 源码GIT下载地址 下载完之后如果要导入eclipse 执行mvn eclipse:eclipse 或者导入IDEA mvn idea:idea 说下个人对rpc和消息的理解: 这2种方式从架构上就是不同的，rpc一般都是同步的，消息都是异步的，用在不同的场景上。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mac树莓派安装kaliLinux]]></title>
      <url>%2F2015%2F12%2F04%2Fmac%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85kaliLinux%2F</url>
      <content type="text"><![CDATA[树莓派到手大概有一周了，想折腾下kali linux，记录下安装步骤。 准备工作，必须品： 树莓派板子一个 5V电源一个 8G SD卡一张 kali linux img 下载地址 选择 “RaspberryPi 2” 版本即可 无线网卡或者网线 显示屏 windows安装怎样在Windows下将Kali安装到SD卡上 下载普通版的树莓派专用Kali Linux，并解压img。 下载名为Win32DiskImager的压缩包并解压其中exe后缀的软件。将SD卡插入你的PC中（记得用读卡器）。 双击打开Win32DiskImager.exe，如果你用的是WIN7或WIN8，则需要点击鼠标右键并选择“以管理员身份运行”。 如果该软件无法自动侦测到你的SD卡，你就要在右上角的下拉菜单中找到SD卡并手动选择它。 在软件的图像文件部分点击小文件夹的图标，找到你刚刚下载的Raspbian.img文件。 点击“写入 or write”按键，Win32DiskImager就会帮你完成其它步骤。安装过程结束后，你就可以拔出SD卡然后将其插入树莓派了。 mac or linux 安装怎样在OSX下将Kali安装到SD卡上 下载普通版的树莓派专用Kali Linux，并解压img。 SD卡插入电脑 使用df -h 命令查看你插入的SD卡，一般类似 /dev/disk0s4 每个人的机器数字是不一样的 使用diskutil list查看SD卡的名字，一般类似 /dev/disk4 然后使用diskutil unmount /dev/disk0s4 命令，卸载已经挂载的SD卡 使用diskutil list查看是否已经卸载，并使用sudo dd bs=4m if=kali-linux.img(这里是你解压img的名字) of=/dev/rdisk2(这里是你SD卡的位置) 写入完成就可以了，然后执行diskutil unmountDisk /dev/disk2推出SD卡。！！！这一步一定要执行，否则可能不会正常开机。你就可以拔出SD卡然后将其插入树莓派了。 树莓派开机 插入SD卡后可正常开机，kali linux 默认用户名密码 root toor 一定要自行修改，否则很可能会被人猜出来的。 说下坑 我查了网上各种资料，都没有给出IMG的下载地址，官网的armhf不能用好么，查了查文档也没找到在哪写的armhf和armel的区别。最终使用了上面我给出的下载地址，下完之后才可以用。 还有，下载之后要验证一下和官网的验证值是否一致，否则有可能自己就成了老黑客的肉鸡，验证方式下载网站已经给出。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[树莓派ntp时间同步问题]]></title>
      <url>%2F2015%2F11%2F30%2F%E6%A0%91%E8%8E%93%E6%B4%BEntp%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[今天刚到手树莓派，看了下时间，于是上网搜了下时间同步的问题。然而我按照网上修改的同步服务器并不能解决问题，于是自己试着改了一下。 前提：你要选择正确了时区，运行sudo raspi-config 选择第4项，回车，继续选择第2个，回车，然后选择Aisa，回车，再次选择重庆或者上海，这样时区就调整好了。网上大部分都说在/etc/ntpd.conf 下 server 0.debain.pool.ntp.org iburst server 1.debain.pool.ntp.org iburst server 2.debain.pool.ntp.org iburst server 3.debain.pool.ntp.org iburst 调整服务器为server asia.pool.ntp.org iburst，我自己试了并不可以，于是我参考了一下我的Mac，用了苹果的时间同步服务器，最终修改为server time.apple.com iburst然后重启ntp服务sudo service ntp restart即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[读spring源码深度解析]]></title>
      <url>%2F2015%2F11%2F12%2F%E8%AF%BBspring%E6%BA%90%E7%A0%81%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%2F</url>
      <content type="text"><![CDATA[工作也有几年了，以前也尝试过想要读spring源码，但由于前几年没有参考资料，所以很难去理解，最近发现一本spring源码深度解析，怀着试试看的心情，踏上了源码之路。 记录一下自己遇到的问题，初次读完之后感觉到了spring的强大之处，处处都是设计模式，把代码拆的很分散，但理解上就很难了。 源码下载，spring最新的git源码地址为spring源码 由于spring3.X以后就是使用gradle构建了，所以还需要安装gradle，Mac OS 可以使用HomeBrew brew install gradle 即可 安装好gradle以后，可以在想要查看的spring项目下执行gradle eclipse 生成eclipse的配置文件 最后在Eclipse-&gt;import-&gt;existing Eclipse projects进行导入就可以了 书中有一个查看类实现的接口图，一开始不知道在哪使用，后来发现对着想要查看的类右击，出现选项菜单，点击-&gt;Open Type Hierarchy 即可，默认是显示的子类实现，然后点击上方小图标show the supertype Hierarchy即可 书中作者看到了哪个类中没有做明确提示，如果找不到需要自行搜索，我用的STS，commond+shift+l 可按关键字搜索]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo博客提交到搜索引擎]]></title>
      <url>%2F2014%2F06%2F22%2Fhexo%E5%8D%9A%E5%AE%A2%E6%8F%90%E4%BA%A4%E5%88%B0%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%2F</url>
      <content type="text"><![CDATA[使用了hexo搭建博客之后，于是想把博客地址提交到搜索引擎当中，让搜索引擎来收录，在提交搜索引擎的时候遇到了一些问题记录下来。让搜索引擎收录的方式有以下几种: 提交某个html文件到你的博客根目录下 添加网站的meta标签 CNAME方式 当我使用第1种方式时，发现其实上传的文件是在index文件中包含了进来，所以搜索引擎不会识别，所以使用了第2种方式。在使用第2种方式时，是需要给index.html添加meta标签，使用hexo的话，如果直接修改.deploy是不可以的，因为执行hexo clean，hexo g两条命令后，是会把文件覆盖的。所以我直接修改了主题中的模板文件，这样在生成index.html的时候就会自动生成进来了。 修改themes-tyrant-layout-_partial-head.ejs文件把meta内容直接加入head即可。 ps:tyrant为博主使用的主题，修改时只需要修改自己主题下的此文件即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo 搭建 github pages 问题]]></title>
      <url>%2F2014%2F05%2F31%2Fhexo-%E6%90%AD%E5%BB%BA-github-pages--%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[由于自己想搭建一个免费的博客，所以找到了万能的github，但在搭建的过程中遇到了几个小问题，所以记下来基本搭建的方法都是参考于利用github搭建博客这个博主已经写的很全了，搭建的过程就不一一提了说下遇到的问题 hexo上传后博客还是官方的建立了github pages的项目，并且使用了官方的建立建好了一个博客，官方默认会在master分支上开出一个gh-pages分支，然后查了官网资料说所有的内容都是显示gh-pages分支上的，但是我用hexo却传不到gh-pages分支上，并且传到了master分支内容也不会显示，后来找到原因是因为我建立的项目名字不是以#你的github帐户.github.io#命名的，所以会使hexo的上传程序传到master分支上也不会起作用，把项目名修改之后就可以了。 添加多说的问题在官网注册后，复制了多说代码，按教程做完之后发现多说模块不显示，所以查看了comment.ejs源代码&lt;% if (config.disqus_shortname &amp;&amp; page.comments){ %&gt; 这里是2个判断，把config.disqus_shortname &amp;&amp; 删掉之后，就可以正常使用了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[我为什么开始写博客]]></title>
      <url>%2F2014%2F05%2F31%2F%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%80%E5%A7%8B%E5%86%99%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[最近参加了几场印象笔记的活动，听大家分享了一些自己坚持做的事，由于最近自己也在整理自己琐碎的事情，感觉虽然自己在技术上一直在积累但那都是自己的眼光和认识，如果与大家分享出来之后这样可以帮助自己有很大的提升。最近这一年来，在新的公司里自己有了很大的成长，但是发现这些成长记录其实只记录在我的印象笔记里或者是自己的经验上，并没有真正的分享出来，以后在这里记录自己遇到的问题以及一些正在学的技术，自己的理解和学习记录。希望在这里可以记录下自己技术成长的轨迹，以便和大家共同成长。]]></content>
    </entry>

    
  
  
</search>
